(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{213:function(v,_,t){"use strict";t.r(_);var e=t(0),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"js-运行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-运行机制"}},[v._v("#")]),v._v(" JS 运行机制")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("单线程？任务队列？事件循环？")])]),v._v(" "),t("h2",{attrs:{id:"单线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[v._v("#")]),v._v(" 单线程")]),v._v(" "),t("p",[v._v("在 JS 引擎中，解析执行 JS 代码的调用栈是唯一的，所有的 JS 代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数，调用栈遵循 LIFO(last in first out 后进先出)的规则，只有栈顶的函数处理完成后出栈，后面的函数再进入栈顶被执行。")]),v._v(" "),t("h2",{attrs:{id:"任务队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[v._v("#")]),v._v(" 任务队列")]),v._v(" "),t("p",[v._v("由于 JS 引擎的单线程设定同一时间只能执行一个任务，所有的任务都需要排队等待被引擎执行，所以如果其中某个任务耗时很长，后面的任务就必须一直等待，为解决这一问题，设计者将所有任务分为两种，同步与异步。")]),v._v(" "),t("p",[v._v("同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。")]),v._v(" "),t("p",[v._v('异步任务：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。')]),v._v(" "),t("p",[v._v("异步任务一般有：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("setTimeout(fn, time)")]),v._v("、"),t("code",[v._v("setInterval(fn, time)")]),v._v(" "),t("ul",[t("li",[v._v("当 "),t("code",[v._v("time")]),v._v(" 参数值缺省时，默认为 0")]),v._v(" "),t("li",[v._v("当 "),t("code",[v._v("time")]),v._v(" 指定的值小于 4 时，增加到 4，即至少需要 4 毫秒，此定时器才会进入任务队列")])])]),v._v(" "),t("li",[v._v("DOM 事件")]),v._v(" "),t("li",[v._v("Ajax 异步与 Promise")])]),v._v(" "),t("p",[t("strong",[v._v("在所有同步任务执行完之前，任何的异步任务是不会执行的")])]),v._v(" "),t("h2",{attrs:{id:"事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[v._v("#")]),v._v(" 事件循环")]),v._v(" "),t("p",[t("em",[v._v("异步任务的执行机制：")])]),v._v(" "),t("ol",[t("li",[v._v("所有同步任务都在主线程上执行，形成一个执行栈(execution context stack)")]),v._v(" "),t("li",[v._v('主线程之外，还存在一个"任务队列"(task queue)，只要异步任务有了运行结果，就在"任务队列"之中放置一个事件')]),v._v(" "),t("li",[v._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行')]),v._v(" "),t("li",[v._v("主线程不断重复上面的第三步")])]),v._v(" "),t("p",[t("strong",[v._v('主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。')])]),v._v(" "),t("h2",{attrs:{id:"异步任务分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步任务分类"}},[v._v("#")]),v._v(" 异步任务分类")]),v._v(" "),t("p",[v._v("异步任务可以分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。")]),v._v(" "),t("p",[v._v("宏任务: "),t("code",[v._v("script(整体代码)")]),v._v("，"),t("code",[v._v("setTimeout")]),v._v("，"),t("code",[v._v("setInterval")]),v._v("，"),t("code",[v._v("setImmediate")]),v._v("(Node)，"),t("code",[v._v("I/O")]),v._v("，"),t("code",[v._v("UI rendering")]),v._v("，"),t("code",[v._v("postMessage")])]),v._v(" "),t("p",[v._v("微任务: "),t("code",[v._v("new Promise().then(回调)")]),v._v("，"),t("code",[v._v("process.nextTick")]),v._v("，"),t("code",[v._v("Object.observe")]),v._v(" (已废弃)，"),t("code",[v._v("MutationObserver")]),v._v(" (html5 新特性)")]),v._v(" "),t("p",[v._v("执行顺序：")]),v._v(" "),t("ol",[t("li",[v._v("由于执行代码入口都是全局任务 "),t("code",[v._v("script")]),v._v("，而全局任务属于宏任务，所以先执行宏任务。当栈为空，同步任务执行完毕时，会先执行微任务队列里的任务")]),v._v(" "),t("li",[v._v("微任务队列里的任务全部执行完毕后，会读取宏任务队列中排队最前的任务")]),v._v(" "),t("li",[v._v("执行宏任务的过程中，遇到微任务，依次加入微任务队列")]),v._v(" "),t("li",[v._v("栈空后，再次读取微任务队列里的任务，依次类推")])]),v._v(" "),t("p",[t("strong",[v._v("当某个宏任务队列的中的任务全部执行完以后，会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列")])])])}),[],!1,null,null,null);_.default=s.exports}}]);